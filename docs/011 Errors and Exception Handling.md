# Errors and Exception Handling

- Types of errors
    1. Syntax Error: This occurs when the Python interpreter finds a grammatical error in your code. For example, forgetting a colon at the end of a line or using incorrect indentation.
    2. IndentationError: This occurs when there is a mismatch in the indentation of the code.
    3. NameError: This occurs when a variable or function is used before it is defined.
    4. TypeError: This occurs when a value of an incorrect type is used in an operation. For example, trying to add a string and an integer.
    5. ZeroDivisionError: This occurs when you try to divide a number by zero.
    6. ValueError: This occurs when a value is passed to a function that is not of the expected type or value.
    7. KeyError: This occurs when you try to access a dictionary key that does not exist.
    8. IndexError: This occurs when you try to access a list element using an index that is out of range.
    9. FileNotFoundError: This occurs when a file you are trying to open does not exist.
    10. ImportError: This occurs when you try to import a module that does not exist.
    
    These errors can be handled using try-except blocks to avoid the termination of the program.
    
- Compile-Time Errors
    
    Compile-time errors are errors that are detected when the code is compiled, before it is executed. These errors are also known as syntax errors or parse errors, and they prevent the code from being executed because the code does not conform to the syntax of the programming language. Some common examples of compile-time errors in Python include:
    
    1. Syntax errors: such as forgetting a colon at the end of a line, using incorrect indentation, or forgetting to close a bracket.
    2. Undeclared variables or functions: using a variable or function that has not been defined.
    3. Incorrect argument types: passing the wrong type of argument to a function.
    4. Misuse of operators: using an operator in a way that is not supported by the language.
    5. Inconsistent indentation: using different indentation levels in different parts of the code.
    
    Compile-time errors are usually easy to detect and fix, as the error messages generated by the Python interpreter are often clear and helpful. However, they can still be frustrating, especially if they are the result of a simple mistake. To minimize the number of compile-time errors, it is important to pay close attention to the syntax of the code and to test the code thoroughly before executing it.
    
- Run-Time Errors
    
    Run-time errors, also known as exceptions, occur during the execution of the code, after it has been compiled. Unlike compile-time errors, run-time errors do not prevent the code from being executed, but they cause the code to stop executing and generate an error message. Some common examples of run-time errors in Python include:
    
    1. Division by zero: attempting to divide a number by zero.
    2. Index out of range: trying to access a list element that does not exist.
    3. Key error: trying to access a dictionary key that does not exist.
    4. Type error: trying to perform an operation on values of the wrong type.
    5. File not found error: trying to open a file that does not exist.
    6. Attribute error: trying to access an attribute of an object that does not exist.
    
    Run-time errors can be handled using try-except blocks in Python, which allow the program to continue executing even if an error occurs. This can be useful for handling unexpected errors and allowing the program to gracefully recover from them. In addition, it is possible to raise custom exceptions, which can be used to signal specific errors that occur within the code.
    
- What is Exception?
    
    An exception is an error that occurs during the execution of a program. Exceptions are unexpected events that interrupt the normal flow of the program and require special handling. They are different from compile-time errors, which are detected when the code is compiled and prevent the code from being executed.
    
    In Python, exceptions are raised when a runtime error occurs, such as dividing by zero, trying to access a list element that does not exist, or trying to open a file that does not exist. When an exception is raised, the program stops executing and generates an error message that describes the exception that was raised.
    
    Exceptions can be handled using try-except blocks in Python, which allow the program to continue executing even if an error occurs. This can be useful for handling unexpected errors and allowing the program to gracefully recover from them. In addition, it is possible to raise custom exceptions, which can be used to signal specific errors that occur within the code.
    
- Need of Exception handling
    
    Exception handling is important for several reasons:
    
    1. Improved program robustness: By handling exceptions, the program can continue executing even if an error occurs, rather than stopping execution immediately. This can improve the overall robustness of the program and allow it to handle unexpected situations.
    2. Better error handling: Exceptions provide a way to handle errors in a structured and consistent way, which makes it easier to write code that is robust and can handle a wide range of error conditions.
    3. Increased user-friendliness: Exception handling can help to improve the user experience by providing meaningful error messages and allowing the program to continue executing even if an error occurs. This can make the program more user-friendly and allow users to more easily understand what went wrong and how to fix it.
    4. Debugging and testing: Exception handling can make it easier to debug and test a program, as it provides a way to isolate errors and handle them in a controlled manner. This can make it easier to identify the root cause of an error and to test different error handling scenarios.
    
    In short, exception handling is an important technique for improving the reliability, robustness, and user-friendliness of a program. It provides a way to handle errors in a structured and consistent way, and can improve the overall quality of the program.
    
- Predefined Exceptions
    
    here are many predefined exceptions in Python that can be raised when certain error conditions occur. Some of the most commonly used exceptions are:
    
    1. **`AttributeError`**: Raised when an attribute reference or assignment fails.
    2. **`TypeError`**: Raised when an operation or function is applied to an object of inappropriate type.
    3. **`NameError`**: Raised when a local or global name is not found.
    4. **`IndexError`**: Raised when a sequence is indexed with an out-of-range number.
    5. **`ValueError`**: Raised when a function or operation receives an argument of the right type but an inappropriate value.
    6. **`ZeroDivisionError`**: Raised when a number is divided by zero.
    7. **`FileNotFoundError`**: Raised when a file or directory cannot be found.
    8. **`KeyError`**: Raised when a dictionary key is not found.
    9. **`OSError`**: Raised when a system-related error occurs.
    10. **`ImportError`**: Raised when an import statement fails to find the module being imported.
    
    These are just a few examples of the many predefined exceptions in Python. When an exception is raised, the program stops executing and generates an error message that describes the exception that was raised. Exception handling using try-except blocks allows the program to continue executing even if an error occurs, which can help to improve the overall robustness of the program.
    
- Try,Except, finally blocks
    
    ```python
    try:
       # code that might raise an exception
       result = 10 / 0
    except ZeroDivisionError:
       # code to handle the exception
       print("Error: Division by zero")
    finally:
       # code that will always be executed
       print("This code will always be executed, regardless of any exceptions")
    ```
    
    In this example, the code in the **`try`** block attempts to divide 10 by 0, which raises a **`ZeroDivisionError`** exception. The code in the **`except`** block is then executed, and the message "Error: Division by zero" is printed. Finally, the code in the **`finally`** block is executed, and the message "This code will always be executed, regardless of any exceptions" is printed.
    
    By using a try-except-finally block, the program can handle the exception in a controlled manner and continue to execute the rest of the code, instead of crashing and producing a traceback.
    
- Nested blocks
    
    ```python
    try:
       # outer try block
       try:
          # inner try block
          result = 10 / 0
       except ZeroDivisionError:
          # inner except block
          print("Inner block: Error: Division by zero")
       finally:
          # inner finally block
          print("Inner block: This code will always be executed, regardless of any exceptions")
    except:
       # outer except block
       print("Outer block: An unexpected error occurred")
    finally:
       # outer finally block
       print("Outer block: This code will always be executed, regardless of any exceptions")
    ```
    
    Nesting try-except blocks can be useful when you want to handle exceptions at different levels of your code, or when you want to handle exceptions differently in different parts of your code
    
- Handling Multiple Exceptions
    
    you can handle multiple exceptions in a single except block using tuple of exception types. Here's an example:
    
    ```python
    try:
       result = 10 / 0
    except (ZeroDivisionError, TypeError):
       print("An error occurred. Either division by zero or type error")
    ```
    
    In this example, the try block raises a **`ZeroDivisionError`** exception when dividing 10 by 0. The except block catches both **`ZeroDivisionError`** and **`TypeError`** exceptions, so either type of error would trigger the code in the except block to be executed, with the message "An error occurred. Either division by zero or type error" being printed.
    
    You can also catch different exceptions in different except blocks, like this:
    
    ```python
    try:
       result = 10 / 0
    except ZeroDivisionError:
       print("Error: Division by zero")
    except TypeError:
       print("Error: Type error")
    ```
    
    In this example, if a **`ZeroDivisionError`** occurs, the message "Error: Division by zero" will be printed. If a **`TypeError`** occurs, the message "Error: Type error" will be printed. If any other type of exception occurs, it will propagate and be handled by any outer except blocks, or result in an unhandled exception and a traceback if no except blocks catch it.
    
- User defined Exceptions
    
    you can define your own exceptions by creating a new class that inherits from the **`Exception`** base class. Here's an example:
    
    ```python
    class CustomException(Exception):
       def __init__(self, message):
          self.message = message
    
    try:
       raise CustomException("A custom error occurred")
    except CustomException as e:
       print(e.message)
    
    '''
    output:
    A custom error occurred
    '''
    ```
    
    In this example, we define a new custom exception class **`CustomException`** that takes a message as its argument. In the try block, we raise the exception using the **`raise`** keyword and passing an instance of the custom exception class to it. In the except block, we catch the custom exception and print its message using the **`e.message`** attribute.
    
    You can create custom exceptions for specific error conditions in your code, and raise them when those conditions are encountered. This allows you to have more fine-grained control over error handling and makes it easier to diagnose and debug problems in your code.
    
- Raise statement
    
    The **`raise`** statement is used to explicitly raise an exception in your code. It is typically used in combination with a **`try`**-**`except`** block to handle exceptions. Here's an example:
    
    ```python
    
    def divide(a, b):
       if b == 0:
          raise ZeroDivisionError("division by zero")
       return a / b
    
    try:
       result = divide(10, 0)
    except ZeroDivisionError as e:
       print(e)
    '''
    output 
    division by zero
    '''
    ```
    
    In this example, we define a function **`divide`** that takes two arguments **`a`** and **`b`**. If **`b`** is equal to zero, we raise a **`ZeroDivisionError`** with a custom error message "division by zero". In the **`try`** block, we call the **`divide`** function with the arguments **`10`** and **`0`**, which will result in a division by zero error. In the **`except`** block, we catch the **`ZeroDivisionError`** and print its message using the **`e`** variable.
    
    The **`raise`** statement allows you to raise specific exceptions and provide a custom error message. This can be useful for signaling specific error conditions in your code and making it easier to diagnose and debug problems.
